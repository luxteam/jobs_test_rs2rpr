
/*
Redshift to RadeonProRender Converter

History:
v.1.0 - first version
v.1.1 - IBL issue, Displacement convertopn in rsMatarial
v.1.2 - Link To Reflaction convertion change in rsMaterial
v.1.3 - Area light convertion
v.1.4 - Ambient Occlusion, Fresnel support
v.1.5 - Clean scene from redshift (dialog)
v.1.6 - Redshift Material Blender convertation, updated all material convertation
v.1.7 - Fix bugs, deleting lights with transforms.
v.1.8 - Opacity convertation in Redshift Material, rsColorLayer support.
v.1.9 - Fix area light conversion
v.2.0 - Add bumpBlend support
v.2.1 - Fix bug with channel converting, fix bug with creating extra materials.
v.2.2 - ColorCorrection support. Update physical light & subsurface material conversion.
v.2.3 - rsVolumeScattering conversion
v.2.4 - Added the ability to re-convert scene
v.2.5 - RedshiftArchitectural conversion updates.
v.2.6 - RedshiftIncandescent conversion updates.
v.2.7 - RedshiftMaterial & RedshiftSubSurface conversion updates
v.2.8 - RedshiftIESLight & RedshiftPortalLight conversion
v.2.9 - Fresnel mode & ss units mode conversion updates in RedshiftMaterial 
v.2.9.1 - Conversion of light units
v.2.9.2 - Update conversion of color+edge tint mode in RedshiftMaterial, VolumeScattering update
v.2.9.2 - Update conversion of metalness in RedshiftArchitectural
v.2.9.4 - Multiscatter layers conversion update in RedshiftMaterial

*/


global proc write_converted_property_log(string $rpr,string $rsMaterial, string $attrRPR, string $attrRS) { 

    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"`;  
    fprint $fileId ("    property " + $rsMaterial + "." + $attrRS + " converted to " + $rpr + "." + $attrRPR + "   \r\n"); 
    fclose $fileId;   
} 

global proc write_own_property_log(string $text) { 

    $filePath =    `file -q -sceneName` + ".log";  
    $fileId = `fopen $filePath "a"`;  
    fprint $fileId ("    " + $text + "   \r\n"); 
    fclose $fileId;   
} 

// dispalcement convertion
global proc convertDisplacement(string $rs_sg, string $rpr) {

    string $displacement[] = `listConnections -type RedshiftDisplacement $rs_sg`;
    if ($displacement[0] != "") {
        string $fileDisplacement[] = `listConnections -type file $displacement[0]`; 
        if ($fileDisplacement[0] != "") {
            setAttr ($rpr + ".displacementEnable") 1;
            catch (`connectAttr -f ($fileDisplacement[0] + ".outColor") ($rpr + ".displacementMap")`);
            copyProperty($rpr, $displacement[0], "scale", "displacementMax");

            string $meshes[] = `listConnections -type mesh $rs_sg`;
            if ($meshes[0] != "") {
                string $shapes[] = `listRelatives -type mesh $meshes[0]`;
                if ($shapes[0] != "") {
                    $rsEnableSubdivision = `getAttr ($shapes[0] + ".rsEnableSubdivision")`;
                    $rsEnableDisplacement = `getAttr ($shapes[0] + ".rsEnableDisplacement")`;
                    if ($rsEnableSubdivision && $rsEnableDisplacement) {
                        copyProperty($rpr, $shapes[0], "rsMaxTessellationSubdivs", "displacementSubdiv");
                    }
                }
            }
            
            write_converted_property_log($rpr , $fileDisplacement[0], "outColor", "displacementMap");
            write_converted_property_log($rpr , $displacement[0], "scale", "displacementMax");
        }
    }

}

global proc string convertRedshiftNormalMap(string $rs, string $source){

    string $rpr;

    if( `objExists ($rs + "_rpr")` ) {

        $rpr = $rs + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility RPRNormal`;
        rename $rpr ($rs + "_rpr"); 
        $rpr = $rs + "_rpr";
        $file = `shadingNode -asTexture -isColorManaged file`;
        $texture = `shadingNode -asUtility place2dTexture`;

        // Logging to file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("    Found Redshift Normal Map: \r\n    name: " + $rs + "\r\n"); 
        fprint $fileId ("    type: " + `objectType $rs` + "\r\n"); 
        fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
        fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
        fprint $fileId ("    Conversion details: \r\n");  
        fclose $fileId;

        connectAttr -f ($texture + ".coverage") ($file + ".coverage");
        connectAttr -f ($texture + ".translateFrame") ($file + ".translateFrame");
        connectAttr -f ($texture + ".rotateFrame") ($file + ".rotateFrame");
        connectAttr -f ($texture + ".mirrorU") ($file + ".mirrorU");
        connectAttr -f ($texture + ".mirrorV") ($file + ".mirrorV");
        connectAttr -f ($texture + ".stagger") ($file + ".stagger");
        connectAttr -f ($texture + ".wrapU") ($file + ".wrapU");
        connectAttr -f ($texture + ".wrapV") ($file + ".wrapV");
        connectAttr -f ($texture + ".repeatUV") ($file + ".repeatUV");
        connectAttr -f ($texture + ".offset") ($file + ".offset");
        connectAttr -f ($texture + ".rotateUV") ($file + ".rotateUV");
        connectAttr -f ($texture + ".noiseUV") ($file + ".noiseUV");
        connectAttr -f ($texture + ".vertexUvOne") ($file + ".vertexUvOne");
        connectAttr -f ($texture + ".vertexUvTwo") ($file + ".vertexUvTwo");
        connectAttr -f ($texture + ".vertexUvThree") ($file + ".vertexUvThree");
        connectAttr -f ($texture + ".vertexCameraOne") ($file + ".vertexCameraOne");
        connectAttr ($texture + ".outUV") ($file + ".uv");
        connectAttr ($texture + ".outUvFilterSize") ($file + ".uvFilterSize");

        connectAttr -f ($file + ".outColor") ($rpr + ".color");

        setAttr -type "string" ($file + ".fileTextureName") `getAttr ($rs + ".tex0")`;
        write_converted_property_log($rpr, $rs, "fileTextureName", "tex0"); 

        copyProperty($rpr, $rs, "scale", "strength");
        
        // Logging to file 
        $filePath =    `file -q -sceneName` + ".log";   
        $fileId = `fopen $filePath "a"` ; 
        fprint $fileId ("    End: " + $rs);  
        fprint $fileId ("\r\n");   
        fclose $fileId;  

    }

    switch ($source) {
        case "outDisplacementVector": $source = "out"; break;
        case "outDisplacementVectorR": $source = "outR"; break;
        case "outDisplacementVectorG": $source = "outG"; break;
        case "outDisplacementVectorB": $source = "outB"; break;
    }

    $rpr += "." + $source;
    return $rpr;
}

global proc string convertRedshiftAmbientOcclusion(string $rs, string $source){

    string $rpr;

    if( `objExists ($rs + "_rpr")` ) {

        $rpr = $rs + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility RPRAmbientOcclusion`;
        rename $rpr ($rs + "_rpr"); 
        $rpr = $rs + "_rpr";

    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    Found Redshift Ambient Occlusion: \r\n    name: " + $rs + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rs` + "\r\n"); 
    fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    Conversion details: \r\n");  
    fclose $fileId;

    // Fields conversion
    copyPropertyColor($rpr, $rs, "bright", "unoccludedColor");
    copyPropertyColor($rpr, $rs, "dark", "occludedColor");
    copyProperty($rpr, $rs, "spread", "radius");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    End: " + $rs); 
    fprint $fileId ("\r\n");   
    fclose $fileId; 

    switch ($source) {
        case "outColor": $source = "output"; break;
        case "outColorR": $source = "outputR"; break;
        case "outColorG": $source = "outputG"; break;
        case "outColorB": $source = "outputB"; break;
    }

    $rpr += "." + $source;
    return $rpr;
}

global proc string convertRedshiftFresnel(string $rs, string $source){

    string $rpr;
    string $fresnel;

    if( `objExists ($rs + "_rpr")` ) {

        $rpr = $rs + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility RPRBlendValue`;
        rename $rpr ($rs + "_rpr"); 
        $rpr = $rs + "_rpr";

        $fresnel = `shadingNode -asUtility RPRFresnel`;
        connectAttr -force ($fresnel + ".out") ($rpr + ".weight");

    }
       
    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    Found Redshift Fresnel: \r\n    name: " + $rs + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rs` + "\r\n"); 
    fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    Conversion details: \r\n");  
    fclose $fileId;

    // Fields conversion
    copyProperty($fresnel, $rs, "ior", "ior");
    copyPropertyColor($rpr, $rs, "facing_color", "inputA");
    copyPropertyColor($rpr, $rs, "perp_color", "inputB");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    End: " + $rs); 
    fprint $fileId ("\r\n");   
    fclose $fileId;  

    switch ($source) {
        case "outColor": $source = "out"; break;
        case "outColorR": $source = "outR"; break;
        case "outColorG": $source = "outG"; break;
        case "outColorB": $source = "outB"; break;
    }

    $rpr += "." + $source;
    return $rpr;
}

global proc string convertRedshiftColorCorrection(string $rs, string $source){

    string $rpr;

    if( `objExists ($rs + "_rpr")` ) {

        $rpr = $rs + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility colorCorrect`;
        rename $rpr ($rs + "_rpr"); 
        $rpr = $rs + "_rpr";

    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    Found Redshift Color Correction: \r\n    name: " + $rs + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rs` + "\r\n"); 
    fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    Conversion details: \r\n");  
    fclose $fileId;

    // Fields conversion
    copyPropertyColor($rpr, $rs, "input", "inColor");
    copyProperty($rpr, $rs, "hue", "hueShift");
    copyProperty($rpr, $rs, "saturation", "satGain");
    copyProperty($rpr, $rs, "level", "valGain");

    // gamma conversion. Doesn't support material conversion.
    string $listConnections[] = `listConnections ($rs+".gamma")`;
    if (size($listConnections)) {   
        string $source = `connectionInfo -sourceFromDestination ($rs+".gamma")`;
        string $source_splited[];
        $numTokens = `tokenize $source "." $source_splited`;
        $source = $source_splited[0] + ".outColor";
        if (catch(`connectAttr -force $source ($rpr + ".colGamma")`)) { 
            write_own_property_log("Connection failed. Check the connectors. ");
        } else { 
            write_converted_property_log($rpr, $rs, "colGamma", $source);  
        }  
    } else {
        $gamma = `getAttr ($rs + ".gamma")`;
        if (catch(`setAttr ($rpr + ".colGamma") $gamma $gamma $gamma`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rpr, $rs, "gamma", "colGamma");  
        }   
    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    End: " + $rs); 
    fprint $fileId ("\r\n");   
    fclose $fileId;  

    $rpr += "." + $source;
    return $rpr;
}

global proc string convertRedshiftBumpMap(string $rs, string $source){

    string $rpr;

    if( `objExists ($rs + "_rpr")` ) {

        $rpr = $rs + "_rpr";

    } else {

        $rpr = `shadingNode -asUtility RPRBump`;
        rename $rpr ($rs + "_rpr"); 
        $rpr = $rs + "_rpr";
    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    Found Redshift Bump Map: \r\n    name: " + $rs + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rs` + "\r\n"); 
    fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    Conversion details: \r\n");  
    fclose $fileId;

    // Fields conversion
    string $source_input = `connectionInfo -sourceFromDestination ($rs + ".input")`;
    if ($source_input != "") {
        connectAttr -force $source_input ($rpr + ".color");
        write_converted_property_log($rpr, $rs, "color", $source_input);
    }

    copyProperty($rpr, $rs, "scale", "strength");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    End: " + $rs); 
    fprint $fileId ("\r\n");   
    fclose $fileId; 

    $rpr += "." + $source;
    return $rpr;
}


global proc string convertRedshiftColorLayer(string $rs, string $source){

    string $rpr;

    if( `objExists ($rs + "_rpr")` ) {

        $rpr = $rs + "_rpr";

    } else {

        $rpr = `shadingNode -asShader RPRBlendMaterial`;
        rename $rpr ($rs + "_rpr"); 
        $rpr = $rs + "_rpr";

    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    string $type = `objectType $rs`;
    string $typeRPR = `objectType $rpr`;
    fprint $fileId ("    Found Redshift Color Layer: \r\n    name: " + $rs + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rs` + "\r\n"); 
    fprint $fileId ("    Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    Conversion details: \r\n");  
    fclose $fileId;

    // Fields conversion
    copyPropertyColor($rpr, $rs, "base_color", "color0");
    copyPropertyColor($rpr, $rs, "layer1_color", "color1");
    copyProperty($rpr, $rs, "layer1_mask", "weight");

    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("    End: " + $rs); 
    fprint $fileId ("\r\n");   
    fclose $fileId; 

    $rpr += "." + $source;
    return $rpr;
}

global proc string convertRedshiftBumpBlender(string $rs, string $source){

    string $rpr;
    string $rpr_blend;

    if( `objExists ($rs + "_rpr")` ) {

        $rpr = $rs + "_rpr";

    } else {

        $rpr = `shadingNode -asShader RPRBump`;
        rename $rpr ($rs + "_rpr"); 
        $rpr = $rs + "_rpr";

        $rpr_blend = `shadingNode -asShader RPRBlendMaterial`;
        connectAttr -force ($rpr_blend + ".outColor") ($rpr + ".color");

    }

    string $rsBump0[] = `listConnections -type RedshiftBumpMap ($rs + ".baseInput")`;
    if ($rsBump0[0] != ""){
        string $valueInput0[] = `listConnections ($rsBump0[0] + ".input")`;
        if ($valueInput0[0] != ""){
            connectAttr -force ($valueInput0[0] + ".outColor") ($rpr_blend + ".color0");
        }
    }

    string $rsBump1[] = `listConnections -type RedshiftBumpMap ($rs + ".bumpInput0")`;
    if ($rsBump1[0] != ""){
        string $valueInput1[] = `listConnections ($rsBump1[0] + ".input")`;
        if ($valueInput1[0] != ""){
            connectAttr -force ($valueInput1[0] + ".outColor") ($rpr_blend + ".color1");
        }
    }

    switch ($source) {
        case "outColor": $source = "out"; break;
        case "outColorR": $source = "outR"; break;
        case "outColorG": $source = "outG"; break;
        case "outColorB": $source = "outB"; break;
    }

    $rpr += "." + $source;
    return $rpr;

}


global proc copyProperty(string $rpr, string $rs, string $attrRS, string $attrRPR) { 

    // full name of attribute
    string $tempRS = $rs + "." + $attrRS; 
    string $tempRPR = $rpr + "." + $attrRPR;

    string $listConnections[] = `listConnections $tempRS`;
    string $source;

    if (size($listConnections)) {
        $source = `connectionInfo -sourceFromDestination $tempRS`;
        string $source_splited[];
        tokenize $source "." $source_splited;
        $source = convertRSMaterial($source_splited[0], $source_splited[1]);
        if ($source == "") {
            $source = `connectionInfo -sourceFromDestination $tempRS`;
        }
        if (catch(`connectAttr -force $source ($rpr + "." + $attrRPR)`)) { 
            write_own_property_log("Connection failed. Check the connectors. ");
        } else { 
            write_converted_property_log($rpr, $rs, $attrRPR, $source);  
        }  
    } else {
        $varRS = `getAttr $tempRS`; 
        if (catch(`setAttr $tempRPR $varRS`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rpr, $rs, $attrRPR, $attrRS);  
        }   
    }
} 


global proc copyPropertyColor(string $rpr, string $rs, string $attrRS, string $attrRPR) { 

    // full name of attribute
    string $tempRS = $rs + "." + $attrRS; 
    string $tempRPR = $rpr + "." + $attrRPR;

    string $listConnections[] = `listConnections $tempRS`;
    string $source;

    if (size($listConnections)) {
        $source = `connectionInfo -sourceFromDestination $tempRS`;
        string $source_splited[];
        tokenize $source "." $source_splited;
        $source = convertRSMaterial($source_splited[0], $source_splited[1]);
        if ($source == "") {
            $source = `connectionInfo -sourceFromDestination $tempRS`;
        }
        if (catch(`connectAttr -force $source ($rpr + "." + $attrRPR)`)) { 
            write_own_property_log("Connection failed. Check the connectors. ");
        } else { 
            write_converted_property_log($rpr, $rs, $attrRPR, $source);  
        }  
    } else {
        $varRS_RGB = `getAttr $tempRS`;
        if (catch(`setAttr $tempRPR $varRS_RGB[0] $varRS_RGB[1] $varRS_RGB[2]`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rpr, $rs, $attrRPR, $attrRS);  
        }   
    }
} 


global proc int mapDoesNotExist(string $rpr, string $rs, string $attrRS, string $attrRPR) { 

    // full name of attribute
    string $tempRS = $rs + "." + $attrRS; 
    string $tempRPR = $rpr + "." + $attrRPR;

    string $listConnections[] = `listConnections $tempRS`;
    string $source;

    if (size($listConnections)) {
        $source = `connectionInfo -sourceFromDestination $tempRS`;
        string $source_splited[];
        tokenize $source "." $source_splited;
        $source = convertRSMaterial($source_splited[0], $source_splited[1]);
        if ($source == "") {
            $source = `connectionInfo -sourceFromDestination $tempRS`;
        }
    }

    if (size($listConnections)) {   
        if (catch(`connectAttr -force $source ($rpr + "." + $attrRPR)`)) { 
            write_own_property_log("Connection failed. Check the connectors. ");
        } else { 
            write_converted_property_log($rpr, $rs, $attrRPR, $source);  
            return 0;
        }  
    }   

    return 1; 
    
} 

/////////////////////// 
// RedshiftArchitectural 
/////////////////////// 

global proc string convertRedshiftArchitectural (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;
    
    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        }
    }

    // Enable properties, which are default in RedShift
    defaultEnable($rpr, $rsMaterial, "diffuse", "diffuse_weight");
    defaultEnable($rpr, $rsMaterial, "reflections", "reflectivity");
    defaultEnable($rpr, $rsMaterial, "refraction", "transparency");
    defaultEnable($rpr, $rsMaterial, "emissive", "incandescent_scale");
    defaultEnable($rpr, $rsMaterial, "clearCoat", "refl_base");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // diffuse
    copyPropertyColor($rpr, $rsMaterial, "diffuse", "diffuseColor"); 
    copyProperty($rpr, $rsMaterial, "diffuse_weight", "diffuseWeight");
    copyProperty($rpr, $rsMaterial, "diffuse_roughness", "diffuseRoughness");

    // translucency conversion
    $translucency_enable = `getAttr ($rsMaterial + ".refr_translucency")`;
    if ($translucency_enable) {
        setAttr ($rpr + ".separateBackscatterColor") 1;
        copyPropertyColor($rpr, $rsMaterial, "refr_trans_color", "backscatteringColor");
        copyProperty($rpr, $rsMaterial, "refr_trans_weight", "backscatteringWeight"); 
    }

    // primary reflection
    copyPropertyColor($rpr, $rsMaterial, "refl_color", "reflectColor"); 
    copyProperty($rpr, $rsMaterial, "reflectivity", "reflectWeight");
    copyProperty($rpr, $rsMaterial, "brdf_fresnel_ior", "reflectIOR");

    if (mapDoesNotExist($rpr, $rsMaterial, "refl_gloss", "reflectRoughness")) {  
        $gloss = `getAttr ($rsMaterial + ".refl_gloss")`;
        float $inverted_gloss = 1 - $gloss;
        if (catch(`setAttr ($rpr + ".reflectRoughness") $inverted_gloss`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rpr, $rsMaterial, "refl_gloss", "reflectRoughness");  
        }   
    }

    copyProperty($rpr, $rsMaterial, "anisotropy", "reflectAnisotropy"); 
    copyProperty($rpr, $rsMaterial, "anisotropy_rotation", "reflectAnisotropyRotation"); 

    setAttr ($rpr + ".reflectMetalMaterial") `getAttr ($rsMaterial + ".refl_is_metal")`;

    $brdf_fresnel_type = `getAttr ($rsMaterial + ".brdf_fresnel_type")`;
    if ($brdf_fresnel_type) {
        $brdf_extinction_coeff = `getAttr ($rsMaterial + ".brdf_extinction_coeff")`;
        if ($brdf_extinction_coeff > 2) {
            setAttr ($rpr + ".reflectMetalMaterial") 1;
            setAttr ($rpr + ".reflectMetalness") 1;
            copyPropertyColor($rpr, $rsMaterial, "diffuse", "reflectColor"); 
        }
    }

    // sec reflection

    copyProperty($rpr, $rsMaterial, "refl_base", "coatWeight"); 
    copyPropertyColor($rpr, $rsMaterial, "refl_base_color", "coatColor"); 
        
    // refraction
    copyPropertyColor($rpr, $rsMaterial, "refr_color", "refractColor");
    copyProperty($rpr, $rsMaterial, "transparency", "refractWeight"); 

    if (mapDoesNotExist($rpr, $rsMaterial, "refr_gloss", "refractRoughness")) {  
        $gloss = `getAttr ($rsMaterial + ".refr_gloss")`;
        float $inverted_gloss = 1 - $gloss;
        if (catch(`setAttr ($rpr + ".refractRoughness") $inverted_gloss`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rpr, $rsMaterial, "refr_gloss", "refractRoughness");  
        }   
    }

    $fog_enable = `getAttr ($rsMaterial + ".refr_falloff_on")`;
    if ($fog_enable) {
        copyProperty($rpr, $rsMaterial, "refr_falloff_dist", "refractAbsorptionDistance"); 
    }

    $end_color_enable = `getAttr ($rsMaterial + ".refr_falloff_color_on")`;
    if ($end_color_enable) {
        copyPropertyColor($rpr, $rsMaterial, "refr_falloff_color", "refractAbsorbColor"); 
    } else {
        copyPropertyColor($rpr, $rsMaterial, "refr_color", "refractAbsorbColor"); 
    }

    setAttr ($rpr + ".refractAllowCaustics") `getAttr ($rsMaterial + ".do_refractive_caustics")`;
        
    // emissive
    copyPropertyColor($rpr, $rsMaterial, "additional_color", "emissiveColor");
    copyProperty($rpr, $rsMaterial, "incandescent_scale", "emissiveWeight"); 

    setAttr ($rpr + ".transparencyEnable") 1;
    if (mapDoesNotExist($rpr, $rsMaterial, "cutout_opacity", "transparencyLevel")) {  
        $opacity = `getAttr ($rsMaterial + ".cutout_opacity")`;
        float $inverted_opacity = 1 - $opacity;
        if (catch(`setAttr ($rpr + ".transparencyLevel") $inverted_opacity`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rpr, $rsMaterial, "cutout_opacity", "transparencyLevel");  
        }   
    }
    
            
    // Logging to file    
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftCarPaint 
/////////////////////// 

global proc string convertRedshiftCarPaint (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        }
    }

    // Enable properties, which are default in RedShift
    defaultEnable($rpr, $rsMaterial, "diffuse", "diffuse_weight");
    defaultEnable($rpr, $rsMaterial, "reflections", "spec_weight");
    defaultEnable($rpr, $rsMaterial, "clearCoat", "clearcoat_weight");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId; 

    // Fields conversion
    copyPropertyColor($rpr, $rsMaterial, "base_color", "diffuseColor");
    copyProperty($rpr, $rsMaterial, "diffuse_weight", "diffuseWeight");
    copyPropertyColor($rpr, $rsMaterial, "spec_color", "reflectColor");
    copyProperty($rpr, $rsMaterial, "spec_weight", "reflectWeight");
    copyPropertyColor($rpr, $rsMaterial, "clearcoat_color", "coatColor");
    copyProperty($rpr, $rsMaterial, "clearcoat_weight", "coatWeight");

    // Logging in file
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  
    
    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftHair 
/////////////////////// 

global proc string convertRedshiftHair (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        }
    }

    // Enable properties, which are default in RedShift
    //
    //

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;  

    // Fields conversion
    // 
    //

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftIncandescent 
/////////////////////// 

global proc string convertRedshiftIncandescent (string $rsMaterial, string $source) { 
    
    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;
    
    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        } 
    }

    // Enable properties, which are default in RedShift
    setAttr ($rpr + ".diffuse") 0;
    setAttr ($rpr + ".transparencyEnable") 1;
    defaultEnable($rpr, $rsMaterial, "emissive", "intensity");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;  

    // Fields conversion
    copyProperty($rpr, $rsMaterial, "intensity", "emissiveIntensity");
    copyProperty($rpr, $rsMaterial, "alpha", "transparencyLevel");
    
    setAttr ($rpr + ".emissiveDoubleSided") `getAttr ($rsMaterial + ".doublesided")`;

    $transparencyLevel = 1 - `getAttr ($rsMaterial + ".alpha")`;
    setAttr ($rpr + ".transparencyLevel") $transparencyLevel;

    $color_mode = `getAttr ($rsMaterial + ".colorMode")`;
    if ($color_mode) {

        // Temperature

        float $colorR;
        float $colorG;
        float $colorB;

        $temperature = `getAttr ($rsMaterial + ".temperature")` / 100;

        if ($temperature <= 66) {
            $colorR = 255;
        } else {
            $colorR = $temperature - 60;
            $colorR = 329.698727446 * `pow $colorR -0.1332047592`;
            if ($colorR < 0) { $colorR = 0; }
            if ($colorR > 255) { $colorR = 255; }
        }

        if ($temperature <= 66) {
            $colorG = $temperature;
            $colorG = 99.4708025861 * `log $colorG` - 161.1195681661;
            if ($colorG < 0) { $colorG = 0; }
            if ($colorG > 255) { $colorG = 255; }
        } else {
            $colorG = $temperature - 60;
            $colorG = 288.1221695283 * `pow $colorG -0.0755148492`;
            if ($colorG < 0) { $colorG = 0; }
            if ($colorG > 255) { $colorG = 255; }
        }

        if ($temperature >= 66) {
            $colorB = 255;
        } else if ($temperature <= 19) {
            $colorB = 0;
        } else {
            $colorB = $temperature - 10;
            $colorB = 138.5177312231 * `log $colorB` - 305.0447927307;
            if ($colorB < 0) { $colorB = 0; }
            if ($colorB > 255) { $colorB = 255; }
        }

        $colorR = $colorR / 255;
        $colorG = $colorG / 255;
        $colorB = $colorB / 255;

        setAttr ($rpr + ".emissiveColor") $colorR $colorG $colorB;

    } else {
        copyPropertyColor($rpr, $rsMaterial, "color", "emissiveColor");
    }

    

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftMaterial 
/////////////////////// 

global proc string convertRedshiftMaterial (string $rsMaterial, string $source) {

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;

        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");

            convertDisplacement($sg, $rpr);
        }
    }

    // Enable properties, which are default in RedShift.
    defaultEnable($rpr, $rsMaterial, "diffuse", "diffuse_weight");
    defaultEnable($rpr, $rsMaterial, "reflections", "refl_weight");
    defaultEnable($rpr, $rsMaterial, "refraction", "refr_weight");
    defaultEnable($rpr, $rsMaterial, "clearCoat", "coat_weight");
    defaultEnable($rpr, $rsMaterial, "emissive", "emission_weight");
    defaultEnable($rpr, $rsMaterial, "sssEnable", "ms_amount");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;  

    // Fields conversion
    copyPropertyColor($rpr, $rsMaterial, "diffuse_color", "diffuseColor");
    copyProperty($rpr, $rsMaterial, "diffuse_weight", "diffuseWeight");
    copyProperty($rpr, $rsMaterial, "diffuse_roughness", "diffuseRoughness");

    copyPropertyColor($rpr, $rsMaterial, "refl_color", "reflectColor");
    copyProperty($rpr, $rsMaterial, "refl_weight", "reflectWeight");
    copyProperty($rpr, $rsMaterial, "refl_roughness", "reflectRoughness");
    copyProperty($rpr, $rsMaterial, "refl_aniso", "reflectAnisotropy");
    copyProperty($rpr, $rsMaterial, "refl_aniso_rotation", "reflectAnisotropyRotation");
    
    // Fresnel type conversion
    float $refl_reflectivity[] = `getAttr ($rsMaterial + ".refl_reflectivity")`;
    float $blend_color[];

    $refl_fr_mode = `getAttr ($rsMaterial + ".refl_fresnel_mode" )`;
    if ($refl_fr_mode == 3) {
        copyProperty($rpr, $rsMaterial, "refl_ior", "reflectIOR");
    }
    if ($refl_fr_mode == 2) {
        $metalness = `getAttr ($rsMaterial + ".refl_metalness" )`;
        if ($metalness>0) {
            setAttr ($rpr + ".reflectMetalMaterial") 1;
            copyProperty($rpr, $rsMaterial, "refl_metalness", "reflectMetalness");
        }

        float $diffuse_color[] = `getAttr ($rsMaterial + ".diffuse_color")`;

        $blend_color[0] = $refl_reflectivity[0] * $diffuse_color[0];
        $blend_color[1] = $refl_reflectivity[1] * $diffuse_color[1];
        $blend_color[2] = $refl_reflectivity[2] * $diffuse_color[2];

        setAttr ($rpr + ".reflectColor") $blend_color[0] $blend_color[1] $blend_color[2];

    }
    if ($refl_fr_mode == 1) {

        float $edge_tint[] = `getAttr ($rsMaterial + ".refl_edge_tint")`;

        // not metal
        if (!($edge_tint[0] || $edge_tint[1] || $edge_tint[2])) {
            float $max_value = `max $refl_reflectivity[0] $refl_reflectivity[1]`;
            $max_value = `max $max_value $refl_reflectivity[2]`;
            if ($max_value == 1) {
                $max_value = 0.9999;
            }
            if ($max_value == 0) {
                $max_value = 0.0001;
            }
            float $ior = -1 * ($max_value + 1 + 2 * `sqrt $max_value`) / ($max_value - 1);
            if (catch(`setAttr ($rpr + ".reflectIOR") $ior`)) { 
                setAttr ($rpr + ".reflectIOR") 10;
            }

            float $refl_color[] = `getAttr ($rsMaterial + ".refl_color")`;

            if ($refl_color[0] != 0 && $refl_reflectivity[0] != 0) {
                $blend_color[0] = ($refl_reflectivity[0] + $refl_color[0]) / 2;
            } else {
                $blend_color[0] = 0;
            }
            if ($refl_color[1] != 0 && $refl_reflectivity[1] != 0) {
                $blend_color[1] = ($refl_reflectivity[1] + $refl_color[1]) / 2;
            } else {
                $blend_color[1] = 0;
            }
            if ($refl_color[2] != 0 && $refl_reflectivity[2] != 0) {
                $blend_color[2] = ($refl_reflectivity[2] + $refl_color[2]) / 2;
            } else {
                $blend_color[2] = 0;
            }
            setAttr ($rpr + ".reflectColor") $blend_color[0] $blend_color[1] $blend_color[2];

        // metal 
        } else {
    
            if ($edge_tint[0] != 0 && $refl_reflectivity[0] != 0) {
                $blend_color[0] = ($refl_reflectivity[0] + $edge_tint[0]) / 2;
            } else {
                $blend_color[0] = 0;
            }
            if ($edge_tint[1] != 0 && $refl_reflectivity[1] != 0) {
                $blend_color[1] = ($refl_reflectivity[1] + $edge_tint[1]) / 2;
            } else {
                $blend_color[1] = 0;
            }
            if ($edge_tint[2] != 0 && $refl_reflectivity[2] != 0) {
                $blend_color[2] = ($refl_reflectivity[2] + $edge_tint[2]) / 2;
            } else {
                $blend_color[2] = 0;
            }
            setAttr ($rpr + ".reflectColor") $blend_color[0] $blend_color[1] $blend_color[2];
            setAttr ($rpr + ".reflectMetalMaterial") 1;
            setAttr ($rpr + ".reflectMetalness") 1;
        }
    }
    if ($refl_fr_mode == 0) {
        copyProperty($rpr, $rsMaterial, "refl_ior30", "reflectIOR");
    }
    
    
    copyPropertyColor($rpr, $rsMaterial, "refr_color", "refractColor");
    copyProperty($rpr, $rsMaterial, "refr_weight", "refractWeight");
    copyProperty($rpr, $rsMaterial, "refr_roughness", "refractRoughness");
    copyProperty($rpr, $rsMaterial, "refr_ior", "refractIor");
    copyProperty($rpr, $rsMaterial, "refr_use_base_IOR", "refractLinkToReflect");
    copyProperty($rpr, $rsMaterial, "refr_thin_walled", "refractThinSurface");

    $ss_unitsMode = `getAttr ($rsMaterial + ".ss_unitsMode" )`;
    if ($ss_unitsMode == 0) {
        copyPropertyColor($rpr, $rsMaterial, "refr_transmittance", "refractAbsorbColor");
        if (mapDoesNotExist($rpr, $rsMaterial, "refr_absorption_scale", "refractAbsorptionDistance")) {  
            $absorption = `getAttr ($rsMaterial + ".refr_absorption_scale")`;
            float $inverted_absorption = 1 / $absorption;
            if (catch(`setAttr ($rpr + ".refractAbsorptionDistance") $inverted_absorption`)) { 
                write_own_property_log("Copy failed. Check the values and their boundaries. ");
            } else { 
                write_converted_property_log($rpr, $rsMaterial, "refr_absorption_scale", "refractAbsorptionDistance");  
            }   
        }
    } else if ($ss_unitsMode == 1) {
        if (mapDoesNotExist($rpr, $rsMaterial, "ss_extinction_coeff", "refractAbsorbColor")) {  
            $ss_ext_coeffR = 1 - `getAttr ($rsMaterial + ".ss_extinction_coeffR")`;
            $ss_ext_coeffG = 1 - `getAttr ($rsMaterial + ".ss_extinction_coeffG")`;
            $ss_ext_coeffB = 1 - `getAttr ($rsMaterial + ".ss_extinction_coeffB")`;
            if (catch(`setAttr ($rpr + ".refractAbsorbColor") $ss_ext_coeffR $ss_ext_coeffG $ss_ext_coeffB`)) { 
                write_own_property_log("Copy failed. Check the values and their boundaries. ");
            } else { 
                write_converted_property_log($rpr, $rsMaterial, "ss_extinction_coeff", "refractAbsorbColor");  
            }  
        }
        if (mapDoesNotExist($rpr, $rsMaterial, "ss_extinction_scale", "refractAbsorptionDistance")) {  
            $absorption = `getAttr ($rsMaterial + ".ss_extinction_scale")`;
            float $inverted_absorption = 1 / $absorption;
            if (catch(`setAttr ($rpr + ".refractAbsorptionDistance") $inverted_absorption`)) { 
                write_own_property_log("Copy failed. Check the values and their boundaries. ");
            } else { 
                write_converted_property_log($rpr, $rsMaterial, "ss_extinction_scale", "refractAbsorptionDistance");  
            }   
        }
    }
    
    copyPropertyColor($rpr, $rsMaterial, "coat_color", "coatColor");
    copyProperty($rpr, $rsMaterial, "coat_weight", "coatWeight");
    copyProperty($rpr, $rsMaterial, "coat_roughness", "coatRoughness");   
    copyPropertyColor($rpr, $rsMaterial, "coat_transmittance", "coatTransmissionColor"); 
    
    $coat_fr_mode = `getAttr ($rsMaterial + ".coat_fresnel_mode" )`;
    if ($coat_fr_mode == 3) {
        copyProperty($rpr, $rsMaterial, "coat_ior", "coatIor");
    }

    copyPropertyColor($rpr, $rsMaterial, "emission_color", "emissiveColor");
    copyProperty($rpr, $rsMaterial, "emission_weight", "emissiveWeight");
    copyProperty($rpr, $rsMaterial, "emission_weight", "emissiveIntensity");

    copyProperty($rpr, $rsMaterial, "ms_amount", "backscatteringWeight");
    copyProperty($rpr, $rsMaterial, "ms_amount", "sssWeight");

    $ms_amount = `getAttr ($rsMaterial + ".ms_amount" )`;
    if ($ms_amount > 0) {
        float $scatter_color[];
        $ms_weight0 = `getAttr ($rsMaterial + ".ms_weight0" )`;
        $ms_weight1 = `getAttr ($rsMaterial + ".ms_weight1" )`;
        $ms_weight2 = `getAttr ($rsMaterial + ".ms_weight2" )`;
        int $count = 3;
        if ($ms_weight0 == 0) {$count -= 1;}
        if ($ms_weight1 == 0) {$count -= 1;}
        if ($ms_weight2 == 0) {$count -= 1;}
        $color0 = `getAttr ($rsMaterial + ".ms_color0")`;
        $color1 = `getAttr ($rsMaterial + ".ms_color1")`;
        $color2 = `getAttr ($rsMaterial + ".ms_color2")`;
        $scatter_color[0] = ($color0[0] * $ms_weight0 + $color1[0] * $ms_weight1 + $color2[0] * $ms_weight2) / $count;
        $scatter_color[1] = ($color0[1] * $ms_weight0 + $color1[1] * $ms_weight1 + $color2[1] * $ms_weight2) / $count;
        $scatter_color[2] = ($color0[2] * $ms_weight0 + $color1[2] * $ms_weight1 + $color2[2] * $ms_weight2) / $count;
        setAttr ($rpr + ".volumeScatter") $scatter_color[0] $scatter_color[1] $scatter_color[2];

        float $radius[];
        $ms_radius0 = `getAttr ($rsMaterial + ".ms_radius0" )`;
        $ms_radius1 = `getAttr ($rsMaterial + ".ms_radius1" )`;
        $ms_radius2 = `getAttr ($rsMaterial + ".ms_radius2" )`;
        $ms_radius_scale = `getAttr ($rsMaterial + ".ms_radius_scale" )`;
        float $avg_radius = ($ms_radius0 * $ms_weight0 + $ms_radius1 * $ms_weight1 + $ms_radius2 * $ms_weight2) / $count;
        $radius[0] = ($avg_radius + $scatter_color[0]) * $ms_radius_scale * $ms_amount;
        $radius[1] = ($avg_radius + $scatter_color[1]) * $ms_radius_scale * $ms_amount;
        $radius[2] = ($avg_radius + $scatter_color[2]) * $ms_radius_scale * $ms_amount;
        setAttr ($rpr + ".subsurfaceRadius") $radius[0] $radius[1] $radius[2];

    }

    $backscatteringWeight = `getAttr ($rsMaterial + ".transl_weight")`;
    if ($backscatteringWeight) {
        setAttr ($rpr + ".separateBackscatterColor") 1;
        copyPropertyColor($rpr, $rsMaterial, "transl_color", "backscatteringColor");
        copyProperty($rpr, $rsMaterial, "transl_weight", "backscatteringWeight");
    }

    // Opacity convert. Material conversion doesn't support, because all rsMaterial have outColor, but we need outAlpha.
    string $listConnections[] = `listConnections ($rsMaterial+".opacity_color")`;
    if (size($listConnections)) {   
        string $source = `connectionInfo -sourceFromDestination ($rsMaterial+".opacity_color")`;
        string $source_splited[];
        tokenize $source "." $source_splited;
        $source = $source_splited[0] + "outAlpha";
        if (catch(`connectAttr -force $source ($rpr + ".transparencyLevel")`)) { 
            write_own_property_log("Connection failed. Check the connectors. ");
        } else { 
            setAttr ($rpr + ".transparencyEnable") 1;
            write_converted_property_log($rpr, $rsMaterial, "transparencyLevel", $source);  
        }  
    } else {
        float $opacityRS[] = `getAttr ($rsMaterial+".opacity_color")`;
        float $max_value = `max $opacityRS[0] $opacityRS[1]`;
        $max_value = 1 - `max $max_value $opacityRS[2]`;
        if (catch(`setAttr ($rpr + ".transparencyLevel") $max_value`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            setAttr ($rpr + ".transparencyEnable") 1;
            write_converted_property_log($rpr, $rsMaterial, "transparencyLevel", "opacity_color");  
        }   
    }

    string $bumpConnections[] = `listConnections ($rsMaterial + ".bump_input")`; 
    if ($bumpConnections[0] != "") {
        setAttr ($rpr + ".normalMapEnable") 1;
        copyPropertyColor($rpr, $rsMaterial, "bump_input", "normalMap");
    }
    
    // Logging to file 
    $filePath = `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftMaterialBlender 
/////////////////////// 

global proc string convertRedshiftMaterialBlender (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRBlendMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        } 
    }

    // Enable properties, which are default in RedShift
    //
    //

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;   

    // Fields conversion
    copyPropertyColor($rpr, $rsMaterial, "baseColor", "color0");
    copyPropertyColor($rpr, $rsMaterial, "layerColor1", "color1");

    string $listConnections[] = `listConnections ($rsMaterial + ".blendColor1")`;
    if (size($listConnections)) {   
        if (catch(`connectAttr -force ($listConnections[0] + ".outAlpha") ($rpr + ".weight")`)) { 
            write_own_property_log("Connection failed. Check the connectors. ");
        } else { 
            write_converted_property_log($rpr, $rsMaterial, "weigh", $listConnections[0] + ".outAlpha");  
        }  
    }
    
    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftMatteShadowCatcher 
/////////////////////// 

global proc string convertRedshiftMatteShadowCatcher (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRShadowCatcherMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        } 
    }

    // Enable properties, which are default in RedShift
    //
    // 

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;  

    // Fields conversion
    copyProperty($rpr, $rsMaterial, "backgroundIsEnv", "bgIsEnv");
    copyProperty($rpr, $rsMaterial, "transparency", "shadowTransp");
    copyPropertyColor($rpr, $rsMaterial, "background", "bgColor");
    copyPropertyColor($rpr, $rsMaterial, "shadows", "shadowColor");
        
    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftShaderSwitch 
/////////////////////// 

global proc string convertRedshiftShaderSwitch (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        } 
    }

    // Enable properties, which are default in RedShift
    //
    // 

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;  

    // Fields conversion
    // 
    //

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftSkin 
/////////////////////// 

global proc string convertRedshiftSkin (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        } 
    }

    // Enable properties, which are default in RedShift
    //
    // 

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;   

    // Fields conversion
    // 
    //

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftSprite 
/////////////////////// 

global proc string convertRedshiftSprite (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        } 
    }

    // Enable properties, which are default in RedShift
    //
    //

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;  

    // Fields conversion
    // 
    //

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}

/////////////////////// 
// RedshiftSubSurfaceScatter 
/////////////////////// 

global proc string convertRedshiftSubSurfaceScatter (string $rsMaterial, string $source) { 

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsMaterial + "_rpr")` ) {

        $rpr = $rsMaterial + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRUberMaterial"`; 
        rename $rpr ($rsMaterial + "_rpr");
        $rpr = $rsMaterial + "_rpr"; 

        // Check shading engine in rsMaterial
        $materialSG = `listConnections -type shadingEngine $rsMaterial`;
        if (size($materialSG)) {
            $sg = $rpr + "SG"; 
            sets -renderable true -noSurfaceShader true -empty -name $sg; 
            connectAttr -f ($rpr + ".outColor") ($sg + ".surfaceShader");
        } 
    }

    // Enable properties, which are default in RedShift
    setAttr ($rpr + ".sssEnable") 1;
    setAttr ($rpr + ".separateBackscatterColor") 1;
    setAttr ($rpr + ".reflections") 1;
        
    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift material: \r\n    name: " + $rsMaterial + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsMaterial` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n");
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;   

    // Fields conversion
    setAttr ($rpr + ".diffuseWeight") 0.2;
    setAttr ($rpr + ".backscatteringWeight") 0.8;
    copyProperty($rpr, $rsMaterial, "ior", "reflectIOR");
    copyPropertyColor($rpr, $rsMaterial, "sub_surface_color", "diffuseColor");
    copyPropertyColor($rpr, $rsMaterial, "sub_surface_color", "volumeScatter");
    copyPropertyColor($rpr, $rsMaterial, "scatter_color", "backscatteringColor");

    if (mapDoesNotExist($rpr, $rsMaterial, "scatter_color", "subsurfaceRadius")) {   
        $radius = `getAttr ($rsMaterial + ".scatter_radius")`;
        float $scatterColor[] = `getAttr ($rsMaterial + ".scatter_color")`;
        float $radius0 = $radius + $scatterColor[0] * 1.5;
        float $radius1 = $radius + $scatterColor[1] * 1.5;
        float $radius2 = $radius + $scatterColor[2] * 1.5;
        if (catch(`setAttr ($rpr + ".subsurfaceRadius") $radius0 $radius $radius2`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rpr, $rsMaterial, "scatterColor", "subsurfaceRadius");  
        }   
    }

    if (mapDoesNotExist($rpr, $rsMaterial, "refl_gloss", "reflectRoughness")) {  
        $gloss = `getAttr ($rsMaterial + ".refl_gloss")`;
        float $inverted_gloss = 1 - $gloss;
        if (catch(`setAttr ($rpr + ".reflectRoughness") $inverted_gloss`)) { 
            write_own_property_log("Copy failed. Check the values and their boundaries. ");
        } else { 
            write_converted_property_log($rpr, $rsMaterial, "refl_gloss", "reflectRoughness");  
        }   
    }
       
    // Logging to file  
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rsMaterial);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

    if ($sg == "") {
        $rpr += "." + $source;
    }
    return $rpr; 

}


// Convert scene RedShift to RPR 

global proc convertRedshiftPhysicalSky(string $sky) {
    
    string $SkyNode;

    if( `objExists "RPRSky"`) {
        $SkyNode = "RPRSkyShape";
    } else {
        // create RPRSky
        $SkyNode = `createNode RPRSky -n RPRSkyShape`; 
    }
  
    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift Phisycal sky&sun: \r\n    name: " + $sky + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $sky` + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $SkyNode + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $SkyNode` + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties from rsPhysicalSky
    setAttr (($SkyNode + ".turbidity"), getAttr($sky + ".haze"));
    write_converted_property_log($SkyNode, $sky, "turbidity", "haze");
    setAttr (($SkyNode + ".intensity"), getAttr($sky + ".multiplier"));
    write_converted_property_log($SkyNode, $sky, "intensity", "multiplier");
    setAttr (($SkyNode + ".groundColor"), getAttr($sky + ".ground_colorR"), getAttr($sky + ".ground_colorG"), getAttr($sky + ".ground_colorB"));
    write_converted_property_log($SkyNode, $sky, "groundColor", "ground_color");
    setAttr (($SkyNode + ".filterColor"), getAttr($sky + ".night_colorR"), getAttr($sky + ".night_colorG"), getAttr($sky + ".night_colorB"));
    write_converted_property_log($SkyNode, $sky, "filterColor", "night_color");
    setAttr (($SkyNode + ".sunDiskSize"), getAttr($sky + ".sun_disk_scale"));
    write_converted_property_log($SkyNode, $sky, "sunDiskSize", "sun_disk_scale");
    setAttr (($SkyNode + ".sunGlow"), getAttr($sky + ".sun_glow_intensity"));
    write_converted_property_log($SkyNode, $sky, "sunGlow", "sun_glow_intensity");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";  
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $SkyNode);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  
}


global proc convertRedshiftEnvironment(string $env) {

    // IBL Shape
    string $iblShape;

    // IBL transform
    string $iblTransform[];

    if( `objExists "RPRIBL"`) {
        $iblShape = "RPRIBLShape";
        $iblTransform = {"RPRIBL"};
    } else {
        // create IBL
        $iblShape = `createNode RPRIBL -n RPRIBLShape`;
        $iblTransform = `listRelatives -p $iblShape`;
        setAttr ($iblTransform[0] + ".scaleX") 1001.25663706144;
        setAttr ($iblTransform[0] + ".scaleY") 1001.25663706144;
        setAttr ($iblTransform[0] + ".scaleZ") 1001.25663706144;
        rename $iblTransform[0] RPRIBL;
    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift Environment: \r\n    name: " + $env + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $env` + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $iblShape + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $iblShape` + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;
  
    // display IBL option
    copyProperty($iblShape, $env, "backPlateEnabled", "display");

    // Copy properties from rsEnvironment
    string $connections[] = `listConnections $env`;
    for ($each in $connections) {
       if ( `objectType $each` == "place3dTexture" ) {
           setAttr ($iblTransform[0]+".rotateX", getAttr ($each+".rotateX"));
           setAttr ($iblTransform[0]+".rotateY", getAttr ($each+".rotateY"));
           setAttr ($iblTransform[0]+".rotateZ", getAttr ($each+".rotateZ"));
           write_converted_property_log($iblTransform[0], $each, "rotateX", "rotateX");
           write_converted_property_log($iblTransform[0], $each, "rotateY", "rotateY");
           write_converted_property_log($iblTransform[0], $each, "rotateZ", "rotateZ");
           if (`getAttr ($env + ".texMode")` == 0) {
              $map = `getAttr ($env + ".tex0")`;
              setAttr -type "string" ($iblTransform[0]+".filePath") $map;
              write_converted_property_log($iblTransform[0], $env, "filePath", "tex0");
           }
       }
    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $iblShape);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;
}

global proc convertRedshiftDomeLight(string $dome) {

   // IBL Shape
    string $iblShape;

    // IBL transform
    string $iblTransform[];

    if( `objExists "RPRIBL"`) {
        $iblShape = "RPRIBLShape";
        $iblTransform = {"RPRIBL"};
    } else {
        // create IBL
        $iblShape = `createNode RPRIBL -n RPRIBLShape`;
        $iblTransform = `listRelatives -p $iblShape`;
        setAttr ($iblTransform[0] + ".scaleX") 1001.25663706144;
        setAttr ($iblTransform[0] + ".scaleY") 1001.25663706144;
        setAttr ($iblTransform[0] + ".scaleZ") 1001.25663706144;
        rename $iblTransform[0] RPRIBL;
    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift Light: \r\n    name: " + $dome + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $dome` + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $iblShape + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $iblShape` + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // display IBL option
    $iblDisplayValue = `getAttr ($dome + ".background_enable")`;
    setAttr ($iblShape + ".display") $iblDisplayValue;

    // Copy properties from DomeLight
    $map = `getAttr ($dome + ".tex0")`;
    setAttr -type "string" ($iblShape + ".filePath") $map;
    write_converted_property_log($iblShape, $dome, "filePath", "tex0"); 

    $parentDome = `listRelatives -p $dome`;
    $rotateY = `getAttr ($parentDome[0] + ".rotateY")`;
    $rotateY = $rotateY - 90;
    setAttr ($iblTransform[0] + ".rotateY") $rotateY;

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $iblShape);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;
}

global proc convertRedshiftPhysicalLight(string $rs_light) {

    // Light transform
    string $lightTransform[];

    // Light shape
    string $lightShape;

    // Redshift light transform
    $rs_transform = `listRelatives -p $rs_light`;

    string $rslightName[];
    int $size = `tokenize $rs_light "|" $rslightName`;

    if( `objExists ($rslightName[1] + "_rpr") `) {

        $lightShape = $rslightName[1] + "_rpr";
        $lightTransform = `listRelatives -p $lightShape`;

    } else {

        $lightShape = `createNode RPRPhysicalLight -n RPRPhysicalLightShape`;
        rename $lightShape ($rslightName[$size - 1] + "_rpr");
        $lightShape = $rslightName[$size - 1] + "_rpr";
        $lightTransform = `listRelatives -p $lightShape`;
        rename $lightTransform[0] ($rs_transform[0] + "_rpr");
        $lightTransform[0] = $rs_transform[0] + "_rpr";

    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift Light: \r\n    name: " + $rs_light + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rs_light` + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $lightShape + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $lightShape` + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties from rsLight

    $lightType = `getAttr ($rs_light + ".lightType")`;
    if ($lightType == 0) { // area
        setAttr ($lightShape + ".lightType") 0;
    } else if ($lightType == 1) { // point
        setAttr ($lightShape + ".lightType") 2;
    } else if ($lightType == 2) { // spot
        setAttr ($lightShape + ".lightType") 1;
    } else if ($lightType == 3) { // directional
        setAttr ($lightShape + ".lightType") 3;
    }

    $colorMode = `getAttr ($rs_light + ".colorMode")`;
    if ($colorMode == 0) { 
        setAttr ($lightShape + ".colorMode") 0;
    } else if ($colorMode == 1) {
        setAttr ($lightShape + ".colorMode") 1;
    } else if ($colorMode == 2) { 
        setAttr ($lightShape + ".colorMode") 1;
    }

    float $intensity = `getAttr ($rs_light + ".intensity")`;
    float $exposure = `getAttr ($rs_light + ".exposure")`;
    int $unitsType = `getAttr ($rs_light + ".unitsType")`;
    if ($unitsType == 0) {
        setAttr ($lightShape + ".intensityUnits") 1;
        print("TEEE1");
        setAttr ($lightShape + ".lightIntensity") ($intensity * (`pow 2 $exposure`));
    } else if ($unitsType == 1) {
        setAttr ($lightShape + ".intensityUnits") 1;
        setAttr ($lightShape + ".lightIntensity") ($intensity * (`pow 2 $exposure`) / 1000);
    } else if ($unitsType == 2) {
        setAttr ($lightShape + ".intensityUnits") 1;
        setAttr ($lightShape + ".lightIntensity") ($intensity * (`pow 2 $exposure`) / 10000);
    } else if ($unitsType == 3) {
        setAttr ($lightShape + ".intensityUnits") 2;
        setAttr ($lightShape + ".lightIntensity") ($intensity * (`pow 2 $exposure`) / 10);
        copyProperty($lightShape, $rs_light, "lumensperwatt", "luminousEfficacy");
    } else if ($unitsType == 4) {
        setAttr ($lightShape + ".intensityUnits") 3;
        setAttr ($lightShape + ".lightIntensity") ($intensity * (`pow 2 $exposure`) / 10);
        copyProperty($lightShape, $rs_light, "lumensperwatt", "luminousEfficacy");
    }

    $angle = `getAttr ($rs_light + ".spotConeFalloffAngle")`;
    setAttr ($lightShape + ".spotLightOuterConeFalloff") ($angle * 3.5);
    copyProperty($lightShape, $rs_light, "spotConeAngle", "spotLightInnerConeAngle");

    copyPropertyColor($lightShape, $rs_light, "color", "colorPicker");

    copyProperty($lightTransform[0], $rs_transform[0], "translateX", "translateX");
    copyProperty($lightTransform[0], $rs_transform[0], "translateY", "translateY");
    copyProperty($lightTransform[0], $rs_transform[0], "translateZ", "translateZ");
    copyProperty($lightTransform[0], $rs_transform[0], "rotateX", "rotateX");
    copyProperty($lightTransform[0], $rs_transform[0], "rotateY", "rotateY");
    copyProperty($lightTransform[0], $rs_transform[0], "rotateZ", "rotateZ");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleX", "scaleX");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleY", "scaleY");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleZ", "scaleZ");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $lightShape);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;
}

global proc convertRedshiftPortalLight(string $rs_light) {

    // Light transform
    string $lightTransform[];

    // Light shape
    string $lightShape;

    // Redshift light transform
    $rs_transform = `listRelatives -p $rs_light`;

    string $rslightName[];
    int $size = `tokenize $rs_light "|" $rslightName`;

    if( `objExists ($rslightName[1] + "_rpr") `) {

        $lightShape = $rslightName[1] + "_rpr";
        $lightTransform = `listRelatives -p $lightShape`;

    } else {

        $lightShape = `createNode RPRPhysicalLight -n RPRPhysicalLightShape`;
        rename $lightShape ($rslightName[$size - 1] + "_rpr");
        $lightShape = $rslightName[$size - 1] + "_rpr";
        $lightTransform = `listRelatives -p $lightShape`;
        rename $lightTransform[0] ($rs_transform[0] + "_rpr");
        $lightTransform[0] = $rs_transform[0] + "_rpr";

    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift Light: \r\n    name: " + $rs_light + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rs_light` + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $lightShape + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $lightShape` + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties from rsLight

    setAttr ($lightShape + ".lightType") 0;

    float $intensity = `getAttr ($rs_light + ".multiplier")`;
    float $exposure = `getAttr ($rs_light + ".exposure")`;
    $intensity = $intensity * (`pow 2 $exposure`);
    setAttr ($lightShape + ".lightIntensity") $intensity;
    setAttr ($lightShape + ".intensityUnits") 1;
    
    copyPropertyColor($lightShape, $rs_light, "tint_color", "colorPicker");

    $visibleR = `getAttr ($rs_light + ".transparencyR")`;
    $visibleG = `getAttr ($rs_light + ".transparencyG")`;
    $visibleB = `getAttr ($rs_light + ".transparencyB")`;
    if (!($visibleR || $visibleG || $visibleB)) {
        setAttr ($lightShape + ".areaLightVisible") 1;
    } else {
        setAttr ($lightShape + ".areaLightVisible") 0;
    }

    copyProperty($lightTransform[0], $rs_transform[0], "translateX", "translateX");
    copyProperty($lightTransform[0], $rs_transform[0], "translateY", "translateY");
    copyProperty($lightTransform[0], $rs_transform[0], "translateZ", "translateZ");
    copyProperty($lightTransform[0], $rs_transform[0], "rotateX", "rotateX");
    copyProperty($lightTransform[0], $rs_transform[0], "rotateY", "rotateY");
    copyProperty($lightTransform[0], $rs_transform[0], "rotateZ", "rotateZ");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleX", "scaleX");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleY", "scaleY");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleZ", "scaleZ");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $lightShape);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;
}

global proc convertRedshiftIESLight(string $rs_light) {

    // Light transform
    string $lightTransform[];

    // Light shape
    string $lightShape;

    // Redshift light transform
    $rs_transform = `listRelatives -p $rs_light`;

    string $rslightName[];
    int $size = `tokenize $rs_light "|" $rslightName`;

    if( `objExists ($rslightName[1] + "_rpr") `) {

        $lightShape = $rslightName[1] + "_rpr";
        $lightTransform = `listRelatives -p $lightShape`;

    } else {

        $lightShape = `createNode RPRIES -n RPRIESLight`;
        rename $lightShape ($rslightName[$size - 1] + "_rpr");
        $lightShape = $rslightName[$size - 1] + "_rpr";
        $lightTransform = `listRelatives -p $lightShape`;
        rename $lightTransform[0] ($rs_transform[0] + "_rpr");
        $lightTransform[0] = $rs_transform[0] + "_rpr";

    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift Light: \r\n    name: " + $rs_light + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rs_light` + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $lightShape + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $lightShape` + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;

    // Copy properties from rsLight

    float $intensity = `getAttr ($rs_light + ".multiplier")`;
    float $exposure = `getAttr ($rs_light + ".exposure")`;
    $intensity = $intensity * (`pow 2 $exposure`);
    setAttr ($lightShape + ".intensity") $intensity;
    
    copyPropertyColor($lightShape, $rs_light, "color", "color");

    setAttr -type "string" ($lightShape + ".iesFile") `getAttr ($rs_light + ".profile")`;

    copyProperty($lightTransform[0], $rs_transform[0], "translateX", "translateX");
    copyProperty($lightTransform[0], $rs_transform[0], "translateY", "translateY");
    copyProperty($lightTransform[0], $rs_transform[0], "translateZ", "translateZ");
    $rotate_X = `getAttr ($rs_transform[0] + ".rotateX")` + 180;
    setAttr ($lightTransform[0] + ".rotateX") $rotate_X;
    copyProperty($lightTransform[0], $rs_transform[0], "rotateY", "rotateY");
    copyProperty($lightTransform[0], $rs_transform[0], "rotateZ", "rotateZ");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleX", "scaleX");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleY", "scaleY");
    copyProperty($lightTransform[0], $rs_transform[0], "scaleZ", "scaleZ");

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log"; 
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $lightShape);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;
}

global proc convertRedshiftVolumeScattering(string $rsVolumeScattering) {

    // RPR Material name
    string $rpr;

    // RPR Material Shading Engine
    string $sg;

    if( `objExists ($rsVolumeScattering + "_rpr")` ) {

        $rpr = $rsVolumeScattering + "_rpr";

    } else {

        // Creating new Uber material
        $rpr = `shadingNode -asShader "RPRVolumeMaterial"`; 
        rename $rpr ($rsVolumeScattering + "_rpr");
        $rpr = $rsVolumeScattering + "_rpr"; 

        $sg = $rpr + "SG"; 
        sets -renderable true -noSurfaceShader true -empty -name $sg; 
        connectAttr -f ($rpr + ".outColor") ($sg + ".volumeShader");

        // create sphere
        polySphere -n Volume;
        setAttr ("Volume.scaleX") 999;
        setAttr ("Volume.scaleY") 999;
        setAttr ("Volume.scaleZ") 999;

        // assign material
        select Volume;
        sets -e -forceElement $sg;

    }

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Found Redshift Volume Scattering: \r\n    name: " + $rsVolumeScattering + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rsVolumeScattering` + "\r\n"); 
    fprint $fileId ("Converting to: \r\n    name: " + $rpr + "\r\n"); 
    fprint $fileId ("    type: " + `objectType $rpr` + "\r\n"); 
    fprint $fileId ("    shading engine: " + $sg + "\r\n"); 
    fprint $fileId ("Conversion details: \r\n");  
    fclose $fileId;  

    // Fields conversion
    copyPropertyColor($rpr, $rsVolumeScattering, "tint", "scatterColor");
    copyProperty($rpr, $rsVolumeScattering, "phase", "scatteringDirection");
    copyPropertyColor($rpr, $rsVolumeScattering, "fogAmbient", "emissionColor");

    $scatterAmount = `getAttr ($rsVolumeScattering + ".scatteringAmount")`;
    float $density = $scatterAmount * 8;
    if (catch(`setAttr ($rpr + ".density") $density`)) { 
        write_own_property_log("Copy failed. Check the values and their boundaries. ");
    } else { 
        write_converted_property_log($rpr, $rsVolumeScattering, "scatteringAmount", "density");  
    }   

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("End: " + $rpr);  
    fprint $fileId ("\r\n\r\n\r\n");  
    fclose $fileId;  

}

// Convert material. Returns new material name.
global proc string convertRSMaterial (string $rsMaterial, string $source) {
    
    string $type = `objectType $rsMaterial`;
    string $rpr;

    switch ($type) {

    case "RedshiftArchitectural": $rpr = convertRedshiftArchitectural($rsMaterial, $source); break;
    case "RedshiftCarPaint": $rpr = convertRedshiftCarPaint($rsMaterial, $source); break;
    case "RedshiftHair": $rpr = convertRedshiftHair($rsMaterial, $source); break;
    case "RedshiftIncandescent": $rpr = convertRedshiftIncandescent($rsMaterial, $source); break;
    case "RedshiftMaterial": $rpr = convertRedshiftMaterial($rsMaterial, $source); break;
    case "RedshiftMaterialBlender": $rpr = convertRedshiftMaterialBlender($rsMaterial, $source); break;
    case "RedshiftMatteShadowCatcher": $rpr = convertRedshiftMatteShadowCatcher($rsMaterial, $source); break;
    case "RedshiftShaderSwitch": $rpr = convertRedshiftShaderSwitch($rsMaterial, $source); break;
    case "RedshiftSkin": $rpr = convertRedshiftSkin($rsMaterial, $source); break;
    case "RedshiftSprite": $rpr = convertRedshiftSprite($rsMaterial, $source); break;
    case "RedshiftSubSurfaceScatter": $rpr = convertRedshiftSubSurfaceScatter($rsMaterial, $source); break;

    //utilities
    case "RedshiftBumpMap": $rpr = convertRedshiftBumpMap($rsMaterial, $source); break;
    case "RedshiftNormalMap": $rpr = convertRedshiftNormalMap($rsMaterial, $source); break;
    case "RedshiftAmbientOcclusion": $rpr = convertRedshiftAmbientOcclusion($rsMaterial, $source); break;
    case "RedshiftFresnel": $rpr = convertRedshiftFresnel($rsMaterial, $source); break;
    case "RedshiftColorLayer": $rpr = convertRedshiftColorLayer($rsMaterial, $source); break;
    case "RedshiftBumpBlender": $rpr = convertRedshiftBumpBlender($rsMaterial, $source); break;
    case "RedshiftColorCorrection": $rpr = convertRedshiftColorCorrection($rsMaterial, $source); break;
    
    default : break;

    }

    return $rpr;

}

// Convert light. Returns new light name.
global proc convertLight (string $light) {
    
    string $type = `objectType $light`;

    switch ($type) {

    case "RedshiftPhysicalLight": convertRedshiftPhysicalLight($light); break;
    case "RedshiftDomeLight": convertRedshiftDomeLight($light); break;
    case "RedshiftPortalLight": convertRedshiftPortalLight($light); break;
    //case "RedshiftPhysicalSun": convertRedshiftPhysicalSun($light); break;
    case "RedshiftIESLight": convertRedshiftIESLight($light); break;
    default : break;

    }
}

global proc int searchRedshiftType(string $obj) {

    if( `objExists $obj` ) {
        string $objType = `objectType $obj`;
        if (substring($objType, 1, 8) == "Redshift") {
            return 1;
        }
    }
    return 0;
}

global proc cleanScene(){

    // Logging to file 
    $filePath =    `file -q -sceneName` + ".log";   
    $fileId = `fopen $filePath "a"` ; 
    fprint $fileId ("Deleted: \r\n"); 
    fclose $fileId;

    string $shEng[];
    string $listMaterials[] = `ls -materials`;
    for ($material in $listMaterials) { 
        if (searchRedshiftType($material)){
            $shEng = `listConnections -type shadingEngine $material`; 
            write_own_property_log($material);
            catch (`delete $shEng[0]`);
            catch (`delete $material`);
        }
    }

    string $listLights[] = `ls -l -type RedshiftDomeLight -type RedshiftIESLight -type RedshiftPhysicalLight -type RedshiftPhysicalSun -type RedshiftPortalLight`;
    string $transform[];
    for ($light in $listLights) {
        $transform = `listRelatives -p $light`;
        catch (`delete $light`);
        catch (`delete $transform[0]`);
    }

    string $listObjects[] = `ls -l`;
    for ($object in $listObjects) {
        if (searchRedshiftType($object)){
            write_own_property_log($object);
            catch (`delete $object`);
        }
    }

}

global proc int checkMaterial(string $material){
    
    if (searchRedshiftType($material)) {
        string $SGs[] = `listConnections -type shadingEngine $material`; 
        if ($SGs[0] != "") {
            return 1;
        }
    }
    return 0;

}

global proc defaultEnable(string $RPRmaterial, string $rsMaterial, string $enable, string $value){
    
    $weight = `getAttr ($rsMaterial + "." + $value)`;
    if ($weight > 0) {
        setAttr ($RPRmaterial + "." + $enable) 1;
    } else {
        setAttr ($RPRmaterial + "." + $enable) 0;
    }   

}

global proc convertScene(){

    // Check plugins
    if( ! `pluginInfo -q -loaded "redshift4maya"` )
    {
        loadPlugin "redshift4maya";
    }
    if( ! `pluginInfo -q -loaded "RadeonProRender"` )
    {
        loadPlugin "RadeonProRender";
    }

    // Convert RedshiftEnvironment
    string $env[] = `ls -type RedshiftEnvironment`;
    if (size($env)) {
       catch (`convertRedshiftEnvironment($env[0])`);
    } 

    // Convert RedshiftPhysicalSky
    string $sky[] = `ls -type RedshiftPhysicalSky`;
    if (size($sky)) {
       catch (`convertRedshiftPhysicalSky($sky[0])`);
    } 

    // Convert RedshiftAtmosphere
    string $atmosphere[] = `ls -type RedshiftVolumeScattering`;
    if (size($atmosphere)) {
       catch (`convertRedshiftVolumeScattering($atmosphere[0])`);
    } 

    // Get all lights from scene
    string $listLights[] = `ls -l -type RedshiftDomeLight -type RedshiftIESLight -type RedshiftPhysicalLight -type RedshiftPhysicalSun -type RedshiftPortalLight`;

    // Convert lights
    for ($light in $listLights) { 
       catch (`convertLight($light)`);
    } 

    // Get all materials from scene
    string $listMaterials[] = `ls -materials`;

    // Array of association of RS & RPR
    string $rsMaterials[];
    string $RPRmaterials[];
    int $i = 0;

    // Convert materials
    for ($each in $listMaterials) {
        if (checkMaterial($each)) {
            $rsMaterials[$i] = $each;
            $RPRmaterials[$i] = convertRSMaterial($each, "");
            $i += 1;
        }
    } 

    for ($k = 0; $k < size($rsMaterials); $k++ ) {
        hyperShade -objects $rsMaterials[$k];
        string $sg[] = `listConnections -type shadingEngine $RPRmaterials[$k]`;
        sets -e -forceElement $sg[0];
    }
    
}


global proc auto_launch(){
    convertScene();
    cleanScene();
}

